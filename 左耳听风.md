# 左耳听风

### 开篇词 | 洞悉技术的本质，享受科技的乐趣

### 01 | 程序员如何用技术变现（上）

要去经历大多数人经历不到的，要把学习时间花在那些比较难的地方。

要写文章就要写没有人写过的，或是别人写过，但我能写得更好的。

更重要的是，技术和知识完全是可以变现的。

并不是社会不尊重程序员，只要你能帮上大忙，就一定会赢得别人的尊重。

### 02 | 程序员如何用技术变现（下）

第一，千里之行，积于跬步。任何一件成功的大事，都是通过一个一个的小成功达到的。

你得让自己身边的人有求于你，或是向别人推荐你。这就需要你能够掌握大多数人不能掌握的技能或技术，需要你更多地学习，并要有更多的别人没有的经验和经历。

第二，关注有价值的东西。价值其实是受供需关系影响的，供大于求，就没什么价值，供不应求，就有价值。

真正缺的其实是有能力能够解决技术难题的人，能够提高团队人效的人。

在学习技术的过程一定要多问自己两个问题：“一，这个技术解决什么问题？为什么别的同类技术做不到？二，为什么是这样解决的？有没有更好的方式？”

第三，找到能体现价值的地方。在一家高速发展的公司中，技术人员的价值可以达到最大化。

第四，动手能力很重要。在解决任何一个具体问题的时候，有没有动手能力就成为了关键。

第五，关注技术付费点。一个是能帮别人“挣钱”的地方；另一个是能帮别人“省钱”的地方。

第六，提升自己的能力和经历。付费的前提是信任，只有你提升自己的能力和经历后，别人才会对你有一定的信任。

第七，找到有价值的信息源。

第八，输出观点和价值观。

第九，朋友圈很重要。

### 03 | Equifax 信息泄露始末

### 04 | 从 Equifax 信息泄露看数据安全

***数据泄露攻击***

**表面的攻击：**

利用程序框架或库的已知漏洞。

暴力破解密码。利用密码字典库或是已经泄露的密码来“撞库”。

代码注入。通过程序员代码的安全性问题，如 SQL 注入、XSS 攻击、CSRF 攻击等取得用户的权限。

利用程序日志不小心泄露的信息。

社会工程学。

**数据管理上的问题：**

只有一层安全。

弱密码。密码系统应该不能让用户设置如此简单的密码，而且还要定期更换。最好的方式是通过数据证书、VPN、双因子验证的方式来登录。

向公网暴露了内部系统。

未对系统及时打安全补丁。

安全日志被暴露。

保存了不必要保存的用户数据。

密码没有被合理地散列。一则需要用目前公认安全的算法（比如 SHA-2 256），二则要加一个安全随机数作为盐（salt）。

***专家建议***

理解你的软件产品中使用了哪些支持性框架和库，它们的版本号分别是多少。时刻跟踪影响这些产品和版本的最新安全性声明。

建立一个流程，来快速地部署带有安全补丁的软件产品。

所有复杂的软件都有漏洞。

建立多个安全层。

针对公网资源，建立对异常访问模式的监控机制。

***技术上的安全做法***

安全防范最好是做到连自己内部员工都能防。

首先，我们需要把我们的关键数据定义出来，然后把这些关键数据隔离出来，隔离到一个安全级别非常高的地方。所谓安全级别非常高的地方，即这个地方需要有如安全审计、安全监控、安全访问。

一般来说，在这个区域内，这些敏感数据只入不出。通过提供服务接口来让别的系统只能在这个区域内操作这些数据，而不是把数据传出去，让别的系统在外部来操作这些数据。

另外，如果业务必需返回用户的数据，对于像信用卡这样的关键数据是死也不能返回全部数据的，只能返回一个被“马赛克”了的数据（隐藏掉部分信息）。就算需要返回一些数据（如用户的地址），那么也需要在传输层上加密返回。

而用户加密的算法一定要采用非对称加密的方式，而且还要加上密钥的自动化更换。

这个区域中的数据也是需要加密存放的，而加密使用的密钥则需要放在另外一个区域中。也就是说，被加密的数据和用于加密的密钥是由不同的人来管理的，有密钥的人没有数据，有数据的人没有密钥，这两拨人可以有访问自己系统的权限，但是没有访问对方系统的权限。

密钥一定要做到随机生成，最好是对于不同用户的数据有不同的密钥，并且时不时地就能自动化更新一下，这样就可以做到内部防范。

用户需要更新密钥时，需要对用户做身份鉴别，可以通过双因子认证，也可以通过更为严格的物理身份验证。

最后，每当这些关键信息传到外部系统，需要做通知，最好是通知用户和自己的管理员。并且限制外部系统的数据访问量，超过访问量后，需要报警或是拒绝访问。

### 05 | 何为技术领导力？

***技术重要吗？***

“野蛮开采” | “精耕细作”

***什么是技术领导力？***

尊重技术，追求核心基础技术。

追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理。

解放生产力，追逐人效的提高。

开发抽象和高质量的可以重用的技术组件。

坚持高于社会主流的技术标准和要求。

***如何拥有技术领导力？***

**“技术领导力”特质**

能够发现问题。能够发现现有方案的问题。

能够提供解决问题的思路和方案，并能比较这些方案的优缺点。

能够做出正确的技术决定。用什么技术、什么解决方案、怎样实现来完成一个项目。

能够用更优雅，更简单，更容易的方式来解决问题。

能够提高代码或软件的扩展性、重用性和可维护性。

能够用正确的方式管理团队。所谓正确的方式，一方面是，让正确的人做正确的事，并发挥每个人的潜力；另一方面是，可以提高团队的生产力和人效，找到最有价值的需求，用最少的成本实现之。并且，可以不断地提高自身和团队的标准。

创新能力。能够使用新的方法、新的方式解决问题，追逐新的工具和技术。

一句话，总是在提供解决问题的思路和方案的人才是有技术领导力的人。

**如何拥有“技术领导力”**

扎实的基础技术；非同一般的学习能力；坚持做正确的事；不断提高对自己的要求标准

### 06 | 如何才能拥有技术领导力？

***第一，你要吃透基础技术***

基础技术是各种上层技术共同的基础。吃透基础技术是为了更好地理解程序的运行原理，并基于这些基础技术进化出更优化的产品。

**编程部分**

C 语言 / 编程范式 / 算法和数据结构

**系统部分**

计算机系统原理 / 操作系统原理和基础 / 网络基础 / 数据库原理 / 分布式技术架构

《深入理解计算机系统》（Randal E. Bryant）

要学习操作系统知识，一是要仔细观察和探索当前使用的操作系统，二是要阅读操作系统原理相关的图书，三是要阅读 API 文档（如 man pages 和 MSDN Library），并编写调用操作系统功能的程序。这里推荐三本书《UNIX 环境高级编程》、《UNIX 网络编程》和《Windows 核心编程》。

《TCP / IP 详解》

要学习数据库，你可以阅读各类数据库图书，并多做数据库操作以及数据库编程，多观察分析数据库在运行时的性能。

学习分布式技术架构的有效途径是参与到分布式项目的开发中去，并阅读相关论文。

***第二，提高学习能力***

所谓学习能力，就是能够很快地学习新技术，又能在关键技术上深入的能力。

**学习的信息源**

如果今天使用中文搜索就可以满足你的知识需求，那么你就远远落后于这个时代了。如果用英文搜索才能找到你想要的知识，那么你才能算跟得上这个时代。而如果说有的问题你连用英文搜索都找不到，只能到社区里去找作者或者其他人交流，那么可以说你已真正和时代同频了。

**与高手交流**

与高手交流对程序员的学习和成长很有益处，不仅有助于了解热门的技术方向及关键的技术点，更可以通过观察和学习高手的技术思维及解决问题的方式，提高自己的技术前瞻性和技术决策力。

**举一反三的思考**

**不怕困难的态度**

**开放的心态**

带有开放的心态，不拘泥于一个平台、一种语言，往往能带来更多思考，也能得到更好的结果。而且，能在不同的方法和方案间做比较，比较它们的优缺点，那么你会知道在什么样的场景下用什么样的方案，你就会比一般人能够有更全面和更完整的思路。

***第三，坚持做正确的事***

**提高效率的事**

你要学习和掌握良好的时间管理方式，管理好自己的时间，能显著提高自己的效率。

**自动化的事**

**掌握前沿技术的事**

掌握前沿的技术，有利于拓展自己的眼界，也有利于找到更好的工作。

**知识密集型的事**

掌握了领域知识的人的价值依然很高。

**技术驱动的事**

***第四，高标准要求自己***

高标准要求自己，不断地反思、总结和审视自己，才能够提升自己。

**Google 的自我评分卡** / **敏锐的技术嗅觉** / **强调实践，学以致用** / **Lead by Example**

***第五，软技能***

良好的沟通能力、组织能力、驱动力、团队协作能力等等。

《技术领导之路》、《卓有成效的管理者》

### 07 | 推荐阅读：每个程序员都该知道的知识

***每个程序员都应该要读的书***

[What is the single most influential book every programmer should read?](https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read)

《代码大全》/《程序员修练之道》/《计算机程序的构造和解释》/《算法导论》/《设计模式》/《重构》/《人月神话》/《代码整洁之道》/《Effective C++》/《More Effective C++》/《Unix 编程艺术》/《Unix 高级环境编程》

***每个搞计算机专业的学生应有的知识***

[What every computer science major should know](https://matt.might.net/articles/what-cs-majors-should-know/)

首先，对于我们每个人来说，作品集（Portfolio）会比简历（Resume）更有参考意义。所以，在自己的简历中应该放上自己的一些项目经历，或是一些开源软件的贡献，或是你完成的软件的网址等。

其次，计算机专业工作者也要学会与人交流的技巧，包括如何写演示文稿，以及面对质疑时如何与人辩论的能力。

最后，他就各个方面展开计算机专业人士所需要的硬技能：工程类数学、Unix 哲学和实践、系统管理、程序设计语言、离散数学、数据结构与算法、计算机体系结构、操作系统、网络、安全、密码学、软件测试、用户体验、可视化、并行计算、软件工程、形式化方法、图形学、机器人、人工智能、机器学习、数据库等等。

***LinkedIn 高效的代码复查技巧***

[LinkedIn’s Tips for Highly Effective Code Review](https://thenewstack.io/linkedin-code-review/)

LinkedIn 的代码复查有以下几个特点：

强制要求在团队成员之间做代码复查。Code Review 带来的反馈意见让团队成员能够迅速提升自己的技能水平。

通过建立公司范围的 Code Review 工具，这就可以做跨团队的 Code Review。

Code Review 的经验作为员工晋升的参考因素之一。

LinkedIn 要求代码签入版本管理系统前，就对其做清晰的说明，以便复查者了解其目的，促进 Review 的进行。

为了提高员工积极性，LinkedIn 的代码复查工具允许提出“这段代码很棒”之类的话语，以便让好代码的作者得到鼓励。

为 Code Review 的结果写出有目的性的注释。比如“消除重复代码”，“增加了测试覆盖率”等等。长此以往也让团队的价值观得以明确。

Code Review 中，不但要 Review 提交者的代码，还要 Review 提交者做过的测试。

对 Code Review 有明确的期望，不过分关注细枝末节，也不要炫技，而是对要 Review 的代码有一个明确的目标。

***编程语言和代码质量的研究报告***

[A Large-Scale Study of Programming Languages and Code Quality in Github](https://cacm.acm.org/magazines/2017/10/221326-a-large-scale-study-of-programming-languages-and-code-quality-in-github/fulltext)

从查看 bug fix 的 commits 的次数情况来看，C、C++、Objective-C、PHP 和 Python 中有很多很多的 commits 都是和 bug fix 相关的，而 Clojure、Haskell、Ruby、Scala 在 bug fix 的 commits 的数上明显要少很多。

函数式编程语言的 bug 明显比大多数其它语言要好很多。有隐式类型转换的语言明显产生的 bug 数要比强类型的语言要少很多。函数式的静态类型的语言要比函数式的动态类型语言的程序出 bug 的可能性要小很多。

bug 数和软件的领域没有相关性。

bug 的类型和语言是强相关性的。

### 08 | Go 语言，Docker 和新技术

***Go 语言有如下几点体会***

第一，语言简单，上手快。

第二，并行和异步编程几乎无痛点。

第三，Go 语言的 lib 库“麻雀虽小，五脏俱全”。

第四，C 语言的理念和 Python 的姿态。C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且对底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。

***一个技术能不能发展起来的关键***

有没有一个比较好的社区 / 有没有一个工业化的标准 / 有没有一个或多个杀手级应用 / 学习难度是否低，上手是否快 / 有没有一个不错的提高开发效率的开发框架 / 是否有一个或多个巨型的技术公司作为后盾 / 有没有解决软件开发中的痛点

***PaaS 层的技术主要能解决下面这些问题***

软件生产线的问题。持续集成和持续发布，以及 DevOps 中的技术必须通过 PaaS。

分布式服务化的问题。分布式服务化的服务高可用、服务编排、服务调度、服务发现、服务路由，以及分布式服务化的支撑技术完全是 PaaS 的菜。

提高服务的可用性 SLA。提高服务可用性 SLA 所需要的分布式、高可用的技术架构和运维工具，也是 PaaS 层提供的。

软件能力的复用。软件工程中的核心就是软件能力的复用，这一点也完美地体现在 PaaS 平台的技术上。

***为什么要早一点地进入这些新技术***

技术的发展过程非常重要。这个过程中，我收获最大的并不是这些技术本身，而是一个技术的变迁和行业的发展。从中，我看到了非常具体的各种浪潮和思路，这些东西比起 Go 和 Docker 来说更有价值。因为，这不但让我重新思考我已掌握的技术以及如何更好地解决已有的问题，而且还让我看到了未来。

这些关键新技术，可以让你提前抢占技术的先机。这一点对一个需要技术领导力的个人或公司来说都是非常重要的。

### 09 | 答疑解惑：渴望、热情和选择

***加班太严重完全没有时间学习，怎么办？***

可能并不在于加班和工作强度大到没时间，关键看你对学习有多少的渴望程度，对要学的东西有多大的热情。这点是非常重要的，因为学习这事其实挺反人性的。反人性的事基本上都是要付出很多，而且还要坚持很久。所以，如果对学习没有渴望的话，或是不能从学习中找到快乐的话，那么其实是很难坚持的，无论你有没有时间。

***为什么你能够写出这么多东西？***

第一个阶段，是学习的阶段。我会把学习到的东西都以笔记的方式记录下来，方便我以后可以翻出来看看。

第二个阶段，是有利益驱动的阶段。

第三个阶段，是记录自己观点打自己脸的阶段。我能够看到自己成长的过程，并且可以及时修正。

第四个阶段，是与他人交互的阶段。一旦一件事被真正地讨论起来，就会有很多知识命中了我的认知盲区。虽然这会被别人批评或是指责，但是，我能从中收获到更多，因为我会从不同的观点，以及别人的批评中，让自己变得更加完善和成熟。而且，我从写作中还能训练自己的表达能力，这让我能够更好更漂亮地与别人交流和沟通。

***怎样选择自己的人生和职业发展？***

一个是在 20-30 岁，这是打基础的阶段。在这个阶段，我们要的是开阔眼界，把基础打扎实，努力学习和成长。

另一个是在 30-40 岁，这是人生发展的阶段。在这个阶段，你需要明确自己奋斗的方向，需要做有挑战的事儿，需要提升自己的技术领导力。

**一些建议**

客观地审视自己。找到自己的长处，不断地在自己的长处上发展自我。在职场上，审视自己的最佳方式，就是隔三差五就出去面试一把，看看自己在市场上能够到什么样的级别。如果你超过了身边的大多数人，你不妨选择得激进一些冒险一些，否则，还是按部就班地来吧。

确定自己想要什么。注意，你不可能什么都要，你需要极端地知道自己要什么。所谓“极端”，就是自己不会受到其它东西或其他人的影响，不会因为这条路上有人退出你会开始怀疑或者迷茫，也不会因为别的路上有人成功了，你就会羡慕。

注重长期的可能性，而不是短期的功利。20-30 岁应该多去经历一些有挑战的事，多去选择能给自己带来更多可能性的事，多去选择能让自己成长的事，尤其是能让自己开阔眼界的事情。

尽量关注自己会得到的东西，而不是自己会失去的东西。

不要和大众的思维方式一样。因为，绝大多数人都是平庸的，所以，如果你的思维方式和大众一样，这意味着你做出来的选择也会和大众一样平庸。

**感慨**

很多事情能做到什么程度，其实在思想的源头就被决定了，因为它会绝大程度地受到思考问题的出发点、思维方式、格局观、价值观等因素影响。

就我们程序员而言，我认为，编码能力很重要，但是技术视野、技术洞察力，以及我们如何用技术解决问题的能力更为重要。

### 10 | 如何成为一个大家愿意追随的 Leader？

***Leader 和 Boss 的不同***

Boss 是驱动员工，Leader 是指导员工。

Boss 制造畏惧，Leader 制造热情。

Boss 面对错误喜欢使用人事惩罚的手段，而 Leader 面对错误喜欢寻找解决问题的技术或管理方法。

Boss 只是知道怎么做，而 Leader 则是展示怎么做。

Boss 是用人，而 Leader 是发展人。

Boss 从团队收割成绩，而 Leader 则是给予团队成绩。

Boss 喜欢命令和控制（Command + Control），而 Leader 喜欢沟通和协作（Communication + Cooperation）。

Boss 喜欢说“给我上”，而 Leader 喜欢说“跟我上”。

***如何成为众人愿意追随的 Leader***

有没有技术领导力（Leadership），是成为一个 Leader 非常关键的因素。

赢得他人的信任。对于信任来说，并不完全是别人相信你能做到某个事，还有别人愿意向你打开心扉，和你说他心里面最柔软的东西。

开放的心态 + 倾向性的价值观。对于新生事物要有开放的心态，对于每个人的观点都有开放的心态，但并不是要认同所有的观点和事情，成为一个油腔滑调的人。我的这些倾向性可以让别人更清楚地知道我是一个什么样的人，而不会对我琢磨不透，一会东一会西只会让人觉得你太油了，反而会产生距离感和厌恶感。

Lead by Example。要做一个有人愿意跟随的技术 Leader，你需要终身写代码，也就是所谓的 ABC – Always Be Coding。这样，你会得到更多的实际经验，能够非常明白一个技术方案的优缺点，实现复杂度，知道什么是 Best Practice，你的方案才会更具执行力和实践性。当有了执行力，你就会获得更多的成就，而这些成就反过来会让更多的人来跟随你。

保持热情和冲劲。所谓的保持热情和冲劲，并不是自欺欺人，也不是文过饰非，因为掩耳盗铃、掩盖问题、强颜欢笑的方式根本不是热情。真正的热情和冲劲是，正视问题，正视不足，正视错误，从中进行反思和总结得到更好的解决方案，不怕困难，迎难而上。

能够抓住重点，看透事物的本质。

描绘令人激动的方向，提供令人向住的环境。

甘当铺路石，为他人创造机会。别人愿意跟随你，愿意和你共事，有一部分原因是你能够给别人带来更多的可能性和机会，别人觉得和你在一起能够成长，能够进步，你能够带着大家到达更远的地方。帮助别人其实就是帮助自己，成就他人其实也是在成就自己。

### 11 | 程序中的错误处理：错误返回码和异常捕捉

***传统的错误检查***

处理错误最直接的方式是通过错误码，这也是传统的方式，在过程式语言中通常都是用这样的方式处理错误的。

其通过函数的返回值标识是否有错，然后通过全局的 errno 变量并配合一个 errstr 数组来告诉你为什么出错。

这种用返回值 + errno 的错误检查方式会有一些问题：

程序员一不小心就会忘记返回值的检查，从而造成代码的 Bug；

函数接口非常不纯洁，正常值和错误值混淆在一起，导致语义有问题。

Windows 的系统调用开始使用 HRESULT 的返回来统一错误的返回值，这样可以明确函数调用时的返回值是成功还是错误。但这样一来，函数的 input 和 output 只能通过函数的参数来完成，于是出现了所谓的入参和出参这样的区别。

一些参数是入参，一些参数是出参，函数接口变得复杂了一些。而且，依然没有解决函数的成功或失败可以被人为忽略的问题。

**多返回值**

Go 语言的很多函数都会返回 result，err 两个值，于是：

参数基本上就是入参，返回接口把结果和错误分离，这样使得函数的接口语义清晰；

Go 语言中的错误参数如果要忽略，需要显式地忽略，用 _ 这样的变量来忽略；

因为返回的 error 是个接口，所以你可以扩展自定义的错误处理。

if err != nil 这样的语句简直是写到吐，只能在 IDE 中定义一个自动写这段代码的快捷键，而且，正常的逻辑代码会被大量的错误处理打得比较凌乱。

***资源清理***

goto fail：你不能在中间的代码中有 return 语句，因为你需要清理资源。在维护这样的代码时需要格外小心，因为一不注意就会导致资源泄漏的问题。

RAII 使用 C++ 类的机制，在构造函数中分配资源，在析构函数中释放资源。

在 Go 语言中，使用 defer 关键字。

***异常捕捉处理***

try - catch - finally

函数接口在 input（参数）和 output（返回值）以及错误处理的语义是比较清楚的。

正常逻辑的代码可以与错误处理和资源清理的代码分开，提高了代码的可读性。

异常不能被忽略（如果要忽略也需要 catch 住，这是显式忽略）。

在面向对象的语言中（如 Java），异常是个对象，所以，可以实现多态式的 catch。

与状态返回码相比，异常捕捉有一个显著的好处是，函数可以嵌套调用，或是链式调用。

try - catch - finally 有个致命的问题，那就是在异步运行的世界里的问题。try 语句块里的函数运行在另外一个线程中，其中抛出的异常无法在调用者的这个线程中被捕捉。

***错误返回码 vs 异常捕捉***

我个人觉得错误可以分为三个大类：

资源的错误。这一类错误属于程序运行环境的问题。对于这类错误，有的我们可以处理，有的我们则无法处理。

程序的错误。这类是我们自己程序的错误，我们要记录下来，写入日志，最好触发监控系统报警。

用户的错误。对于这类问题，我们需要向用户端报错，让用户自己处理修正他们的输入或操作。

逻辑上分类：

对于我们并不期望会发生的事，我们可以使用异常捕捉；对于我们觉得可能会发生的事，使用返回码。

所以，对于上面三种错误的类型来说，程序中的错误，可能用异常捕捉会比较合适；用户的错误，用返回码比较合适；而资源类的错误，要分情况，是用异常捕捉还是用返回值，要看这事是不应该出现的，还是经常出现的。

在大多数情况下，我们会混用这两种报错的方式，有时候，我们还会把异常转成错误码（比如 HTTP 的 RESTful API），也会把错误码转成异常（比如对系统调用的错误）。

使用错误码还是异常捕捉主要还是看我们的错误处理流程以及代码组织怎么写会更清楚。

### 12 | 程序中的错误处理：异步编程以及我的最佳实践

***异步编程世界里的错误处理***

无法使用返回码。因为函数在“被”异步运行中，所谓的返回只是把处理权交给下一条指令，而不是把函数运行完的结果返回。

无法使用抛异常的方式。除了上述的函数立马返回的原因之外，抛出的异常也在另外一个线程中，不同线程中的栈是完全不一样的，所以主线程的 catch 完全看不到另外一个线程中的异常。

最常用的就是 callback 方式。在异步请求的时候，注册几个 OnSuccess()、 OnFailure() 这样的函数，让在另一个线程中运行的异步代码回调过来。

***Java 异步编程的 Promise 模式***

CompletableFuture

***错误处理的最佳实践***

统一分类的错误字典。最好是在一个地方定义相关的错误。

同类错误的定义最好是可以扩展的。

定义错误的严重程度。

错误日志的输出最好使用错误码，而不是错误信息。打印错误日志的时候，应该使用统一的格式。但最好不要用错误信息，而应使用相应的错误码，错误码不一定是数字，也可以是一个能从错误字典里找到的一个唯一的可以让人读懂的关键字。这样，会非常有利于日志分析软件进行自动化监控，而不是要从错误信息中做语义分析。

忽略错误最好有日志。

对于同一个地方不停的报错，最好不要都打到日志里。最好的实践是，打出一个错误以及出现的次数。

不要用错误处理逻辑来处理业务逻辑。如果一个逻辑控制可以用 if - else 清楚地表达，那就不建议使用异常方式处理。异常捕捉是用来处理不期望发生的事情，而错误码则用来处理可能会发生的事。

对于同类的错误处理，用一样的模式。

尽可能在错误发生的地方处理错误。因为这样会让调用者变得更简单。

向上尽可能地返回原始的错误。如果一定要把错误返回到更高层去处理，那么，应该返回原始的错误，而不是重新发明一个错误。

处理错误时，总是要清理已分配的资源。

不推荐在循环体里处理错误。

不要把大量的代码都放在一个 try 语句块内。

为你的错误定义提供清楚的文档以及每种错误的代码示例。

对于异步的方式，推荐使用 Promise 模式处理错误。

对于分布式的系统，推荐使用 APM 相关的软件。

### 13 | 魔数 0x5f3759df

***计算机的浮点数表示***

在 C 语言中，计算机的浮点数表示用的是 IEEE 754 标准，这个标准的表现形式其实就是把一个 32 bits 分成三段。

第一段占 1 bit，表示符号位。代称为 S（sign）。

第二段占 8 bits，表示指数。代称为 E（Exponent）。

第三段占 23 bits，表示尾数。代称为 M（Mantissa）。

![IEEE 754 浮点数](IEEE 754 浮点数.PNG)

什么叫指数？也就是说，对于任何数 x，其都可以找到一个 n，使得 2^n <= x <= 2^(n+1)。而浮点数的这个指数为了要表示 0.00x 的小数，所以需要有负数，这 8 个 bits 本来可以表示 0 - 255，为了表示负的，取值要放在 [-127, 128] 这个区间中。

尾数位，也就是小数位，但是这里叫偏移量可能好一些。这里的取值是从 [0, 2^23] 中，你可以认为，我们把一条线分成 2^23 个线段，也就是 8388608 个线段。也就是说，把 2^n 到 2^(n+1) 分成了 8388608 个线段，而存储的 M 值，就是从 2^n 到 x 要经过多少个段。

### 14 | 推荐阅读：机器学习 101

***监督式学习***

所谓监督式学习，也就是说，我们需要提供一组学习样本，包括相关的特征数据以及相应的标签。程序可以通过这组样本来学习相关的规律或是模式，然后通过得到的规律或模式来判断没有被打过标签的数据是什么样的数据。

***非监督式学习***

数据是没有被标注过的，所以相关的机器学习算法需要找到这些数据中的共性。

非监督式的学习，可以为我们找到人类很难发现的数据里的规律或模型。所以，也有人将这种学习称为“特征点学习”。其可以让我们自动地为数据进行分类，并找到分类的模型。

监督式学习是在被告诉过正确的答案之后的学习，而非监督式学习是在没有被告诉正确答案时的学习，所以说，非监督式的学习是在大量的非常混乱的数据中找寻一些潜在的关系，这个成本也比较高。

在监督式的学习的算法下，我们可以用一组“狗”的照片来确定某个照片中的物体是不是狗。而在非监督式的学习算法下，我们可以通过一个照片来找到与其相似事物的照片。

***如何找到数据的规律和关联***

机器学习基本就是在已知的样本数据中寻找数据的规律，在未知的数据中找数据的关系。

**基本方法论**

要找到数据中的规律，你需要找到数据中的特征点。

把特征点抽象成数学中的向量，也就是所谓的坐标轴。

抽象成数学向量后，就可以通过某种数学公式来表达这类数据，这就是数据建模。

***相关算法***

[The 10 Algorithms Machine Learning Engineers Need to Know](https://www.kdnuggets.com/2016/08/10-algorithms-machine-learning-engineers.html)

***相关推荐***

### 15 | 时间管理：同扭曲时间的事儿抗争

从管理层到执行层都会想方设法帮助程序员专注地做好开发工作。包括尽可能的不开会，不开长会，需求和设计都是要论证很久才会决定做不做，项目管理会帮你把你处理额外工作的时间也算进去，还会把你在学习上花的时间也计算进去。

***主动管理***

无论什么事情，如果你发现你持续处于被动的状态下，那么你一定要停下来想一想如何把被动变为主动。

如果你发现你的时间老是被别人打断，那么你就要告诉大家，我什么时间段在做什么事，请大家不要打扰我。

可以仿照一下以前在 Outlook 里设置工作日程的方式，把你的工作安排预先设置到一个可以共享的日历上，然后分享给大家，让大家了解你的日程。

你甚至可以要求你的同事，重要的事不要发微信，而是要发邮件，因为微信会有很大概率看不到。

信息管理真的非常重要，因为将信息做好分类，才方便检索，方便你通过自己的优先级来处理信息。

你要主动管理的不是你的时间，而是管理你的同事，管理你的信息。

***学会说“不”***

你要学会对某些事说“不”，甚至是要学习对老板说不。这其实是一种“向上管理”的能力。

**给出另一个你可以做到的方案，而不是把对方的方案直接回绝掉。**

**我不说我不能完全满足你，但我说我可以部分满足你。**

**我不能说不，但是我要有条件地说是。而且，我要把你给我的压力再反过来还给你，看似我给了需求方选择，实际上，我掌握了主动。**

a. 我可以加班加点完成，但是我不保证好的质量，有 bug 你得认，而且事后你要给我 1 个月的时间还债。

b. 我可以加班加点，还能保证质量，但我没办法完成这么多需求，能不能减少一些？

c. 我可以保质保量地完成所有的需求，但是，能不能多给我 2 周时间？

**你要学会在“积极主动的态度下对于不合理的事讨价还价”。只有学会了说“不”，你才能够控制好你的时间。**

***加班和开会***

因为加班干出来了质量不好的软件，于是线上故障很多，要花时间处理，而后面的需求也过来了，发现复杂代码的扩展性很差，越干越慢，越干越烂，越干故障越多。

如果怎么做都要受伤害，那么两害相权取其轻。你要学会比较是项目延期的伤害大，还是线上故障的伤害大，是先苦后甜好，还是积压问题好。

开会，不是讨论问题，而是讨论方案，开会不是要有议题，而是要有议案。

### 16 | 时间管理：如何利用好自己的时间？

***投资自己的时间***

**花时间学习基础知识，花时间读文档。**系统地学习一门技术是非常关键的，所以这个时间是值得投资的。

**花时间在解放自己生产力的事上。**在自动化、可配置、可重用、可扩展上要多花时间。

**花时间在让自己成长的事上。**成长不应该只看在一个公司内，而是要看在行业内，在行业内的成长才是真正的成长。所以，把时间花在能让自己成长，能让自己有更强的竞争力，能让自己有更大的视野，能让自己有更多可能性的事情上。

**花时间在建立高效的环境上。**

***规划自己的时间***

**定义好优先级。**

**最短作业优先。**长作业通常很容易出现“意外情况”让你花更多的时间，但此时你发现还有很多别的事没有做，这会让你产生焦虑感，产生更多的压力，进而导致更慢的生产效率。

**想清楚再做。**如果你没有想清楚，你总是要对已完成的工作进行返工。所以，对于一些没想清楚的事，或是自己不太有信心的事，还是先看看有没有已有的成熟解决方案，或是找更牛的人来给你把把关，帮你出出主意，看看有没有更好、更简单的方式。

**关注长期利益规划。**要多关注长远可以节省多少时间，而不是当前会花费多少时间。宁可在短期延期，也不要透支未来。你要学会规划自己的行动计划，不是短期的，而是一个中长期的。我个人建议是按季度来规划，这个季度做什么，达到什么目标，一年往前走四步，而不是只考虑眼下。

***用好自己的时间***

**将军赶路不追小兔。**能专注地把时间投入到一个有价值的事上是非常重要的。

比如，不要让别人来影响自己的心情，心情被影响了，你一下就会什么都不想干了。再比如，知道哪些是自己可以控制的事，哪些是自己控制不了的事，在自己能控制的地方花时间。

再比如，知道哪些是更有效的路径，是花时间改变别人，还是花时间去寻找志同道合的人。不与不如自己的人争论，也不要尝试花时间去叫醒那些装睡的人。多花时间在有产出的事上，少花时间在说服别人的事上。

**形成习惯。**“做”比“做好”更重要。

*形成正反馈。*学习是逆人性的事儿，但如果在学习过程中不断地有正反馈，就更利于我们坚持下去。要让自己有正反馈，那就需要把时间花在有价值的地方，比如，解决自己和他人的痛点，这样你会收获别人的赞扬和鼓励。

*反思和举一反三。*可以尝试每周末花上点时间思考一下，本周做了哪些事儿？时间安排是否合理？还有哪些可以优化提高的地方？然后思考一下，下周的主要任务是什么？并根据优先级规划一下完成这些任务的顺序。

